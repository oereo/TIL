# Design Pattern

## 용어

- `라이브러리`: 공통으로 사용될 수 있는 특정한 기능들을 모듈화 한 것
    - 폴더명, 파일명 등에 대한 규칙이 없고 프레임워크에 비해 자유로움
- `프레임워크`: 공통으로 사용될 수 있는 특정한 기능들을 모듈화 한 것
    - 폴더명, 파일명 등에 대한 규칙이 있으며 라이브러리에 비해 좀 더 엄격

<br />

## 디자인 패턴 개념

- `디자인 패턴`이란 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록
  하나의 규약 형태로 만들어 놓은 것

<br />

## 디자인 패턴 종류

### 싱글톤 패턴

- 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
- 보통 데이터베이스 연결 모듈에 많이 사용
- 하나의 인스턴스를 만들어 놓고 인스턴스를 다른 모듈이 사용하기 때문에 생성 비용 절감
- 의존성이 높아질 수 있음.

#### 단점

- `TDD`를 할때 방해
- 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 독립적인 인스턴스를 만들기 어려움
- 모듈 간의 결합을 강하게 만들 수 있음 -> `의존성 주입(DI)`를 통해 모듈 간의 결합을 조금 더 느슨하게 만듬.
    - 모듈들을 쉽게 교체 가능 -> 테스팅 용이, 마이그레이션 쉬움
    - 모듈들이 더 분리되므로 클래스 수가 늘어나서 복잡성이 증가, 약간의 런타임 패널티
    - 의존성 주입 원칙: 둘 다 `추상화에 의존`해야 함. 세부사항에 의존하지 말것

<br />

### 팩토리 패턴

- 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴.
- 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴.
- Factory 안에서 if를 남용하지 말고 `Enum 또는 Map`을 사용하자.
    - `Enum`: 상수의 집합을 정의할 때 사용되는 타입. 상수나 메서드 등을 집어넣어서 관리하며 코드를 리팩터링할 때 해당 집합에 관한
      로직 수정 시 이 부분만 수정하면 되므로 리팩터링 시에 강점.

<br />

### 전략 패턴

- 객체의 행위를 바꾸고 싶은 경우 `직접 수정하지 않고` `전략`이라고 부르는 캡슐화한 알고리즘을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴.
    - `컨텍스트`: 상황, 맥락, 문맥을 의미하며 개발자가 어떠한 작업을 완료하는 데 필요한 모든 관련 정보 의미

### 옵저버 패턴

- 주체가 어떤 객체(subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴
    - `주체`: 객체의 상태 변화를 보고 있는 관찰자
    - `옵저버`: 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 '추가 변화 사항'이 생기는 객체

#### 용어 정리

- `상속(extends)` : `자식 클래스`가 `부모 클래스`의 메서드 등을 상속받아 사용하며 자식 클래스에서 추가 및 확장을 할 수 있음.
    - 재사용성, 중복성의 최소화
- `구현(implements)`: 부모 `인터페이스(interface)`를 자식 클래스에서 재정의하여 구현하는 것.
    - 상속 과는 달리 반드시 부모 클래스의 메서드를 재정의하여 구현해야 함.
- `프록시 객체(proxy)`: 어떠한 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체

<br />

### 프록시 패턴과 프록시 서버

- `프록시 패턴(proxy pattern)`: 대상 객체(subject)에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴
    - 객체의 속성, 변환 등을 보완
    - 보안, 데이터 검증, 캐싱, 로깅에 사용
- `프록시 서버에서의 캐싱`: 캐시 안에 정보를 담아두고, 캐시 안에 있는 정보를 요구하는 요청에 대해 다시 저 멀리 있는 원격 서버에 요청을 하지 않고, 캐시 안에
  있는 데이터를 활용. -> 불필요하게 외부와 연결하지 않기 때문에 트래픽을 줄일 수 있음.

- 프록시 서버(proxy server): 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는
  컴퓨터 시스템이나 응용 프로그램을 가리킴.

#### nginx
- 비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버
- 익명 사용자의 직접적인 서버로의 접근을 차단하고 간접적으로 한 단계를 더 거침으로써 보안성을 더욱 강화
- nginx를 프록시 서버로 둬서 실제 포트를 숨길 수 있음.
- 정적 자원을 gzip 압축하거나, 메인 서버 앞단에서의 로깅을 할 수 있음.

#### 용어정리
- `버퍼 오버플로우`: 메모리 공간을 벗어나는 경우
  - 버퍼: 보통 데이터가 저장되는 메모리 공간
- `gzip 압축`: LZ77과 Huffman 코딩의 조합인 DEFLATE 알고리즘을 기반으로 한 압축 기술.
  - 데이터 전송량을 줄일 수 있음.
  - 압축을 해제했을 때 서버에서의 CPU 오버헤드가 있을 수 있기 때문에 gzip 압축 사용 유무 결정

#### CloudFlare
- 전 세계적으로 분산된 서버가 있고 이를 통해 어떠한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 CDN 서비스
- DDOS 공격방어: 
  - 짧은 기간 동안 네트워크에 많은 요청을 보내 네트워크를 마비시켜 웹 사이트의 가용성을 방해하는 공격 유형.
  - cloudFlare는 의심스러운 트래픽, 사용자가 접속하는 것이 아닌 시스템을 통해 오는 트래픽을 자동으로 차단
  - 공격에 대한 방화벽 대시보드 제공

#### Https 구축
- 별도의 인증서 설치 없이 좀 더 쉽게 HTTPS 구축 가능

#### CDN
- 각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크
- 사용자가 웹 서버로부터 콘텐츠를 다운로드하는 시간을 줄임.

#### CORS
- `Cross-Origin Resource Sharing`: 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘
  - Origin: 프로토콜과 호스트 이름, 포트의 조합
  - 프록시 서버를 둬서 프런트엔드 서버에서 요청되는 오리진을 바꿈

<br />

### 이터레이터 패턴
- 이터레이터(iterator)를 사용하여 컬렉션(collection)의 요소들에 접근하는 디자인 패턴
- 순회할 수 있는 여러가지 자료형의 구조와는 상관없이 이터레이터라는 하나의 인터페이스로 순회 가능

<br />

### 노출모듈 패턴
- 실행함수를 통해 private, public 같은 접근 제어자를 만드는 패턴
- `public`: 클래스에 정의된 함수에서 접근 가능하며 자식 클래스와 외부 클래스에서 접근 가능한 범위
- `protected`: 클래스에 정의된 함수에서 접근 가능, 자식 클래스에서 접근 가능하지만 외부 클래스에서 접근 불가능한 범위
- `private`: 클래스에 정의된 함수에서 접근 가능하지만 자식 클래스와 외부 클래스에 접근 불가능한 범위 
- `즉시 실행 함수`: 함수를 정의하자마자 바로 호출하는 함수, 초기화 코드, 라이브러리 내 전역 변수의 충돌 방지 등에 사용

<br />

### MVC 패턴
- 모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴
- `Model`: 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻함.
- `View`: 사용자 인터페이스 요소. 모델을 기반으로 사용자가 볼 수 있는 화면을 뜻함.
- `Controller`: 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며, 이벤트 등 메인 로직 담당

<br />

### MVP 패턴
- MVC 패턴으로부터 파생. MVC에서 C에 해당하는 컨트롤러가 프레젠터(Presenter)로 교체
- 뷰와 프레젠터는 일대일 관계이기 때문에 MVC 패턴보다 더 강한 결합을 지닌 디자인 패턴

<br />

### MVVM 패턴
- MVC의 C에 해당하는 컨트롤러가 뷰모델(View Model)로 바뀐 패턴
- 뷰모델은 뷰를 더 추상화한 계층
- 커맨드와 데이터 바인딩을 가짐.
- 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원
- UI를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉬움.